import json
import sys
from PyQt5 import QtCore, QtGui, QtWidgets

from PyQt5.QtGui import QClipboard, QGuiApplication
from PyQt5.QtWidgets import *
from PyQt5.QtGui import QColor
from PyQt5.QtCore import Qt,QThread,pyqtSignal
from tab_window import Ui_MainWindow
import chardet
import os,re,csv
import pandas as pd
import requests,time
from lxml import etree
from PyQt5.QtCore import QThreadPool


class mywindow(QtWidgets.QMainWindow, Ui_MainWindow):
    signal_1 = QtCore.pyqtSignal(str)
    def __init__(self):
        super(mywindow, self).__init__()
        self.setupUi(self)
        self.setWindowTitle('价格网表格获取 1.0')

        self.start_Button.clicked.connect(self.start_BT)
        self.pause_Button.clicked.connect(self.pause_BT)
        self.stop_Button.clicked.connect(self.stop_BT)

    def start_BT(self):
        print('点击开始按键')
        self.URL = self.lineEdit.text()
        print(self.URL)

        if 'http' not in self.URL:
            QMessageBox.warning(self,'URL出错','网址添与错误，请重新输入！')
            return
        if 'kakaku' not in self.URL:
            QMessageBox.warning(self, '非价格网URL', '输入的不是价格网的网址，请重新输入！')
            return

        self.start_data_thread()
    def pause_BT(self):
        print('点击暂停按键')

    def stop_BT(self):
        print('点击停止按键')

    # 创建并启动线程获取数据，并传递参数
    def start_data_thread(self):

        self.data_thread = Get_kakakutab_Thread(self.URL,[self.start_spinBox.value(),self.stop_spinBox.value()])
        self.data_thread.data_ready.connect(self.updata_tab)
        self.data_thread.start()

    #把线程获取到的数据回写到表格中
    def updata_tab(self,data):
        print('数据回写表格')
        print(data)

#创建获取价格网数据的类
class Get_kakakutab_Thread(QThread):
    # 定义信号，用于在线程中传递数据
    data_ready = pyqtSignal(str)

    def __init__(self, url,parameter):
        super().__init__()
        self.parameter = parameter
        self.url = url
        self.kakaku_urls = []
    def run(self):
        print('线程开始获取')

        #获取网页源码中的javascript 部分并解析出字典后提取kakakuID,也就是K开始的部分
        if 'pdf_pg' in self.url:
            url_value = re.findall(r'[\s\S]+pdf_pg',self.url)[0]
            print(url_value,self.parameter)
            pass
        self.html = self.get_kakaku_html(self.url)
        K_str = re.findall(r'var variationPopupData\s*=\s*(.*?)\s*</script>', self.html, re.DOTALL)[0]
        K_dict = re.findall(r'[\s\S]+}', K_str)[0]
        self.data_dict = json.loads(K_dict)
        # print(self.data_dict)
        for key, value in self.data_dict.items():
            # print(key)
            # 如果字典中存在 "K" 键,则直接提取K
            if "K" in key:
                self.kakaku_urls.append(key)

            # 如果字典中存在 "Items" 键，并且其值是一个列表
            elif "Items" in value and isinstance(value["Items"], list):
                # 遍历 "Items" 列表中的每个字典
                for item in value["Items"]:
                    # 如果字典中存在 "ChildProductID" 键
                    if "ChildProductID" in item:
                        # 将 "ChildProductID" 的值添加到数组中
                        self.kakaku_urls.append(item["ChildProductID"])
        print(self.kakaku_urls,len(self.kakaku_urls))
        # for item in self.kakaku_urls:
        #     print(item)

        # 发送信号，通知主线程数据已准备好
        self.data_ready.emit('list_ID')

    def get_kakaku_html(self,url):
        # print('getkakaku',filenumber)
        hd = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.51 Safari/537.36",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",
            "Accept-Language": "ja,zh-CN;q=0.9,zh;q=0.8",

        }
        htmlcode = requests.get(url, headers=hd)
        global  status_code
        if htmlcode.status_code != 200:
            status_code +=1
        code = htmlcode.apparent_encoding
        # print('code=', code)
        htmlcode.encoding = code
        htmlcode = htmlcode.text
        htmlcode = htmlcode.replace("㈱", "(株)")
        htmlcode = htmlcode.replace("デンキヤ.com	", "デンキヤ.com")
        htmlcode = htmlcode.replace("&lt;", "<")
        htmlcode = htmlcode.replace("&gt;", ">")

        return htmlcode
    def getxpath(self, html):
        print('getxpath')
        tablecode = "//tr"
        mytree = etree.HTML(html)
        # 有时去掉编码可以正确识别网页
        # mytree = etree.HTML(html.encode(code))
        tr_list = mytree.xpath(tablecode)
        # print('lentr',len(tr_list))
        try:
            title = mytree.xpath('//div[@id=\'titleBox\']/div[@class=\'boxL\']/h2/text()')[0]
        except:
            return ''
        try:
            date = mytree.xpath('//div[@class=\'releaseDateWrap\']/span/text()')[0].strip()

        except:
            date = ""
        try:
            pm = mytree.xpath(
                '//div[@id=\'ovBtnBox\']//span[@class=\'num\']/text()|//ul[@class=\'clearfix\']/li[1]/span[@class=\'rankNum\']/text()')[
                0]
        except:
            pm = ""
        try:
            ds = mytree.xpath('//div[@class=\'subInfoObj4\']/span[1]/a/span/text()')[0]
        except:
            ds = 0
        if int(ds) > 50:
            ds = '50'
        # print(title,date,pm,ds)
        a = [[title, date, pm, ds], [title, date, pm, ds]]
        quan_list = []
        for td in tr_list:
            try:
                # xl为序列，jg为价格，zk为在库状态，sj为商品名
                xl = td.xpath('./td[1]/span[1]//text()')
                xl = ''.join(xl)
                # print(xl)
                jg = td.xpath('./td[2]/div[1]/p[1]//text()')
                jg = ''.join(jg)
                # print(jg)
                zk = td.xpath('./td[4]/p[1]//text()')
                zk = ''.join(zk)
                # if '〜' in zk:
                #     zk = zk + '営業日'
                # print(zk)

                sj = td.xpath('./td[5]/div[1]/div[1]/div[1]/p[1]/a[1]//text()')
                sjurl = td.xpath('./td[5]/div[1]/div[2]/a[1]/@href')
                sj = ''.join(sj)
                sjurl = ''.join(sjurl)
                # print(sj,sjurl)

                if xl:
                    a.append([title, date, pm, ds, xl, jg, zk, sj])
                if zk == '○':
                    quan_list.append([xl, jg, zk, sj])
            except:
                pass

        return a,quan_list

    def getxpathphone(self,html, code):
        print('采集手机')
        tablecode = "//tr"
        mytree = etree.HTML(html)
        # mytree = etree.HTML(html.encode(code))
        tr_list = mytree.xpath(tablecode)
        # print(tr_list)
        try:
            title = mytree.xpath('//div[@id=\'titleBox\']/div[@class=\'boxL\']/h2/text()')[0]
        except:
            return '重试'
        try:
            date = mytree.xpath('//div[@class=\'releaseDateWrap\']/span/text()')[0].strip()

        except:
            date = ""
        try:
            pm = mytree.xpath(
                '//div[@id=\'ovBtnBox\']//span[@class=\'num\']/text()|//ul[@class=\'clearfix\']/li[1]/span[@class=\'rankNum\']/text()')[
                0]
        except:
            pm = ""
        try:
            ds = mytree.xpath('//*[@id="SRanking"]/a/text()')[0]
            ds = re.findall('\d+', ds)[0]
        except:
            ds = 0
        shangjiashu = ds
        # print(title, date, pm, ds)
        quan_list = []
        a = [[title, date, pm, ds]]
        for i, td in enumerate(tr_list):
            # print('i=',i)
            try:
                # xl为序列，jg为价格，zk为在库状态，sj为商品名
                xl = td.xpath('./td[1]//text()')
                xl = ''.join(xl)
                # print('xl',xl)
                jg = td.xpath('./td[2]/p[1]/a[1]//text()')
                jg = ''.join(jg)
                # print('jg',jg)
                zk = td.xpath('./td[4]//text()')
                zk = ''.join(zk)
                # print('zk',zk)
                sj = td.xpath('./td[6]//a[1]//text()')
                sj = ''.join(sj)
                # print('sj',sj)
                if xl and '位' in xl:
                    a.append([title, date, pm, ds, xl, jg, '', zk, sj])
                if zk == '有':
                    quan_list.append([xl, jg, zk, sj])
            except:
                # print('序列出错')
                pass

        return a,quan_list

if __name__ == '__main__':
    app = QApplication(sys.argv)
    win = mywindow()

    win.show()
    sys.exit(app.exec_())
